// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'auth_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$AuthEventTearOff {
  const _$AuthEventTearOff();

  _ContinueWithEmail continueWithEmail() {
    return const _ContinueWithEmail();
  }

  _ContinueWithOTP continueWithOTP() {
    return const _ContinueWithOTP();
  }
}

/// @nodoc
const $AuthEvent = _$AuthEventTearOff();

/// @nodoc
mixin _$AuthEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() continueWithEmail,
    required TResult Function() continueWithOTP,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? continueWithEmail,
    TResult Function()? continueWithOTP,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ContinueWithEmail value) continueWithEmail,
    required TResult Function(_ContinueWithOTP value) continueWithOTP,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ContinueWithEmail value)? continueWithEmail,
    TResult Function(_ContinueWithOTP value)? continueWithOTP,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AuthEventCopyWith<$Res> {
  factory $AuthEventCopyWith(AuthEvent value, $Res Function(AuthEvent) then) =
      _$AuthEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$AuthEventCopyWithImpl<$Res> implements $AuthEventCopyWith<$Res> {
  _$AuthEventCopyWithImpl(this._value, this._then);

  final AuthEvent _value;
  // ignore: unused_field
  final $Res Function(AuthEvent) _then;
}

/// @nodoc
abstract class _$ContinueWithEmailCopyWith<$Res> {
  factory _$ContinueWithEmailCopyWith(
          _ContinueWithEmail value, $Res Function(_ContinueWithEmail) then) =
      __$ContinueWithEmailCopyWithImpl<$Res>;
}

/// @nodoc
class __$ContinueWithEmailCopyWithImpl<$Res>
    extends _$AuthEventCopyWithImpl<$Res>
    implements _$ContinueWithEmailCopyWith<$Res> {
  __$ContinueWithEmailCopyWithImpl(
      _ContinueWithEmail _value, $Res Function(_ContinueWithEmail) _then)
      : super(_value, (v) => _then(v as _ContinueWithEmail));

  @override
  _ContinueWithEmail get _value => super._value as _ContinueWithEmail;
}

/// @nodoc

class _$_ContinueWithEmail extends _ContinueWithEmail {
  const _$_ContinueWithEmail() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _ContinueWithEmail);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() continueWithEmail,
    required TResult Function() continueWithOTP,
  }) {
    return continueWithEmail();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? continueWithEmail,
    TResult Function()? continueWithOTP,
    required TResult orElse(),
  }) {
    if (continueWithEmail != null) {
      return continueWithEmail();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ContinueWithEmail value) continueWithEmail,
    required TResult Function(_ContinueWithOTP value) continueWithOTP,
  }) {
    return continueWithEmail(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ContinueWithEmail value)? continueWithEmail,
    TResult Function(_ContinueWithOTP value)? continueWithOTP,
    required TResult orElse(),
  }) {
    if (continueWithEmail != null) {
      return continueWithEmail(this);
    }
    return orElse();
  }
}

abstract class _ContinueWithEmail extends AuthEvent {
  const factory _ContinueWithEmail() = _$_ContinueWithEmail;
  const _ContinueWithEmail._() : super._();
}

/// @nodoc
abstract class _$ContinueWithOTPCopyWith<$Res> {
  factory _$ContinueWithOTPCopyWith(
          _ContinueWithOTP value, $Res Function(_ContinueWithOTP) then) =
      __$ContinueWithOTPCopyWithImpl<$Res>;
}

/// @nodoc
class __$ContinueWithOTPCopyWithImpl<$Res> extends _$AuthEventCopyWithImpl<$Res>
    implements _$ContinueWithOTPCopyWith<$Res> {
  __$ContinueWithOTPCopyWithImpl(
      _ContinueWithOTP _value, $Res Function(_ContinueWithOTP) _then)
      : super(_value, (v) => _then(v as _ContinueWithOTP));

  @override
  _ContinueWithOTP get _value => super._value as _ContinueWithOTP;
}

/// @nodoc

class _$_ContinueWithOTP extends _ContinueWithOTP {
  const _$_ContinueWithOTP() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _ContinueWithOTP);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() continueWithEmail,
    required TResult Function() continueWithOTP,
  }) {
    return continueWithOTP();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? continueWithEmail,
    TResult Function()? continueWithOTP,
    required TResult orElse(),
  }) {
    if (continueWithOTP != null) {
      return continueWithOTP();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ContinueWithEmail value) continueWithEmail,
    required TResult Function(_ContinueWithOTP value) continueWithOTP,
  }) {
    return continueWithOTP(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ContinueWithEmail value)? continueWithEmail,
    TResult Function(_ContinueWithOTP value)? continueWithOTP,
    required TResult orElse(),
  }) {
    if (continueWithOTP != null) {
      return continueWithOTP(this);
    }
    return orElse();
  }
}

abstract class _ContinueWithOTP extends AuthEvent {
  const factory _ContinueWithOTP() = _$_ContinueWithOTP;
  const _ContinueWithOTP._() : super._();
}

/// @nodoc
class _$AuthStateTearOff {
  const _$AuthStateTearOff();

  InitialAuthState initial() {
    return const InitialAuthState();
  }

  LoadingAuthState loading() {
    return const LoadingAuthState();
  }

  SuccessAuthState success() {
    return const SuccessAuthState();
  }

  ErrorAuthState error() {
    return const ErrorAuthState();
  }
}

/// @nodoc
const $AuthState = _$AuthStateTearOff();

/// @nodoc
mixin _$AuthState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() success,
    required TResult Function() error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? success,
    TResult Function()? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialAuthState value) initial,
    required TResult Function(LoadingAuthState value) loading,
    required TResult Function(SuccessAuthState value) success,
    required TResult Function(ErrorAuthState value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialAuthState value)? initial,
    TResult Function(LoadingAuthState value)? loading,
    TResult Function(SuccessAuthState value)? success,
    TResult Function(ErrorAuthState value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AuthStateCopyWith<$Res> {
  factory $AuthStateCopyWith(AuthState value, $Res Function(AuthState) then) =
      _$AuthStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$AuthStateCopyWithImpl<$Res> implements $AuthStateCopyWith<$Res> {
  _$AuthStateCopyWithImpl(this._value, this._then);

  final AuthState _value;
  // ignore: unused_field
  final $Res Function(AuthState) _then;
}

/// @nodoc
abstract class $InitialAuthStateCopyWith<$Res> {
  factory $InitialAuthStateCopyWith(
          InitialAuthState value, $Res Function(InitialAuthState) then) =
      _$InitialAuthStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$InitialAuthStateCopyWithImpl<$Res> extends _$AuthStateCopyWithImpl<$Res>
    implements $InitialAuthStateCopyWith<$Res> {
  _$InitialAuthStateCopyWithImpl(
      InitialAuthState _value, $Res Function(InitialAuthState) _then)
      : super(_value, (v) => _then(v as InitialAuthState));

  @override
  InitialAuthState get _value => super._value as InitialAuthState;
}

/// @nodoc

class _$InitialAuthState extends InitialAuthState {
  const _$InitialAuthState() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is InitialAuthState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() success,
    required TResult Function() error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? success,
    TResult Function()? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialAuthState value) initial,
    required TResult Function(LoadingAuthState value) loading,
    required TResult Function(SuccessAuthState value) success,
    required TResult Function(ErrorAuthState value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialAuthState value)? initial,
    TResult Function(LoadingAuthState value)? loading,
    TResult Function(SuccessAuthState value)? success,
    TResult Function(ErrorAuthState value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class InitialAuthState extends AuthState {
  const factory InitialAuthState() = _$InitialAuthState;
  const InitialAuthState._() : super._();
}

/// @nodoc
abstract class $LoadingAuthStateCopyWith<$Res> {
  factory $LoadingAuthStateCopyWith(
          LoadingAuthState value, $Res Function(LoadingAuthState) then) =
      _$LoadingAuthStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$LoadingAuthStateCopyWithImpl<$Res> extends _$AuthStateCopyWithImpl<$Res>
    implements $LoadingAuthStateCopyWith<$Res> {
  _$LoadingAuthStateCopyWithImpl(
      LoadingAuthState _value, $Res Function(LoadingAuthState) _then)
      : super(_value, (v) => _then(v as LoadingAuthState));

  @override
  LoadingAuthState get _value => super._value as LoadingAuthState;
}

/// @nodoc

class _$LoadingAuthState extends LoadingAuthState {
  const _$LoadingAuthState() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is LoadingAuthState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() success,
    required TResult Function() error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? success,
    TResult Function()? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialAuthState value) initial,
    required TResult Function(LoadingAuthState value) loading,
    required TResult Function(SuccessAuthState value) success,
    required TResult Function(ErrorAuthState value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialAuthState value)? initial,
    TResult Function(LoadingAuthState value)? loading,
    TResult Function(SuccessAuthState value)? success,
    TResult Function(ErrorAuthState value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class LoadingAuthState extends AuthState {
  const factory LoadingAuthState() = _$LoadingAuthState;
  const LoadingAuthState._() : super._();
}

/// @nodoc
abstract class $SuccessAuthStateCopyWith<$Res> {
  factory $SuccessAuthStateCopyWith(
          SuccessAuthState value, $Res Function(SuccessAuthState) then) =
      _$SuccessAuthStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$SuccessAuthStateCopyWithImpl<$Res> extends _$AuthStateCopyWithImpl<$Res>
    implements $SuccessAuthStateCopyWith<$Res> {
  _$SuccessAuthStateCopyWithImpl(
      SuccessAuthState _value, $Res Function(SuccessAuthState) _then)
      : super(_value, (v) => _then(v as SuccessAuthState));

  @override
  SuccessAuthState get _value => super._value as SuccessAuthState;
}

/// @nodoc

class _$SuccessAuthState extends SuccessAuthState {
  const _$SuccessAuthState() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is SuccessAuthState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() success,
    required TResult Function() error,
  }) {
    return success();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? success,
    TResult Function()? error,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialAuthState value) initial,
    required TResult Function(LoadingAuthState value) loading,
    required TResult Function(SuccessAuthState value) success,
    required TResult Function(ErrorAuthState value) error,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialAuthState value)? initial,
    TResult Function(LoadingAuthState value)? loading,
    TResult Function(SuccessAuthState value)? success,
    TResult Function(ErrorAuthState value)? error,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class SuccessAuthState extends AuthState {
  const factory SuccessAuthState() = _$SuccessAuthState;
  const SuccessAuthState._() : super._();
}

/// @nodoc
abstract class $ErrorAuthStateCopyWith<$Res> {
  factory $ErrorAuthStateCopyWith(
          ErrorAuthState value, $Res Function(ErrorAuthState) then) =
      _$ErrorAuthStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$ErrorAuthStateCopyWithImpl<$Res> extends _$AuthStateCopyWithImpl<$Res>
    implements $ErrorAuthStateCopyWith<$Res> {
  _$ErrorAuthStateCopyWithImpl(
      ErrorAuthState _value, $Res Function(ErrorAuthState) _then)
      : super(_value, (v) => _then(v as ErrorAuthState));

  @override
  ErrorAuthState get _value => super._value as ErrorAuthState;
}

/// @nodoc

class _$ErrorAuthState extends ErrorAuthState {
  const _$ErrorAuthState() : super._();

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is ErrorAuthState);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function() success,
    required TResult Function() error,
  }) {
    return error();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function()? success,
    TResult Function()? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitialAuthState value) initial,
    required TResult Function(LoadingAuthState value) loading,
    required TResult Function(SuccessAuthState value) success,
    required TResult Function(ErrorAuthState value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitialAuthState value)? initial,
    TResult Function(LoadingAuthState value)? loading,
    TResult Function(SuccessAuthState value)? success,
    TResult Function(ErrorAuthState value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class ErrorAuthState extends AuthState {
  const factory ErrorAuthState() = _$ErrorAuthState;
  const ErrorAuthState._() : super._();
}
